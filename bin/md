#!/bin/bash

export setCmd="set -eo pipefail"
$setCmd

export PATH=/opt/MonkeyDev/bin:/opt/theos/bin:/usr/local/bin:/usr/bin:/usr/sbin:/bin:/sbin:$PATH

export scriptName="${0##*/}"
export scriptVer="2.0"
export originalArguments=("$@")
export activeActionArg

export MonkeyDevPath="/opt/MonkeyDev"
#默认设备ip
export DefaultDevice="localhost"
#默认端口号
export DefaultPort="2222"

export userName="${SUDO_USER-$USER}"
export userGroup=`id -g $userName`
export userHome=`eval echo ~$userName`
export bashProfileFiles=("$userHome/.zshrc" "$userHome/.bash_profile" "$userHome/.bashrc" "$userHome/.bash_login" "$userHome/.profile")

export tempDirsFile="`mktemp -d -t $scriptName`/tempdirs"
touch "$tempDirsFile"

unset LANG

export ActionNames=("XcodeBuildPhase" "XcodeBuildPhaseLogos" "Help")
export ActionProperty_ShortArg=0
export ActionProperty_ShortUsage=1
export ActionProperty_Options=2
export ActionProperty_MinArgs=3
export ActionProperty_MaxArgs=4
export ActionProperty_Function=5
export ActionProperty_RequireSudo=6
export ActionProperty_LongUsage=7

export Action_XcodeBuildPhaseLogos=("--xcbp-logos" "" "" 0 0 xcodeBuildPhase_Logos false \
"        DO NOT USE. For use by Xcode as a Build Phase for projects created from
        MonkeyDev templates only.")

export Action_XcodeBuildPhase=("--xcbp" "" "" 0 0 xcodeBuildPhase false \
"        DO NOT USE. For use by Xcode as a Build Phase for projects created from
        MonkeyDev templates only.")

export Action_Help=("--help" "" "" 0 0 "" false \
"        Show this help.")

function cleanup() # no args
{
	local exitCode=$?
	set +e
	trap - $signals
	
	removeTempData

	exit $exitCode
}
export signals="0 1 2 3 15"
trap cleanup $signals

function panic() # args: exitCode, message...
{
	local exitCode=$1
	set +e
	
	shift
	[[ "$@" == "" ]] || \
		echo "$@" >&2

	exit $exitCode
}

function determineBashProfileFile()
{
	$setCmd

	local f
	local filePath
	
	for f in "${bashProfileFiles[@]}"; do
		if [[ -f "$f" ]]; then
            if [[ -n `perl -ne 'print $1 if /^(?:export)? *'"MonkeyDevPath"'=(.*)$/' "$f"` ]]; then
    			filePath="$f"
    			break
            fi
		fi
	done
	
	if [[ $filePath == "" ]]; then

		filePath="$bashProfileFiles" # use first array item
		
		touch "$filePath" || \
			panic $? "Failed to touch $filePath"
			
		changeOwn "$userName:$userGroup" "$filePath"
		changeMode 0600 "$filePath"
	fi
	
	# return #
	echo "$filePath"
}

function removeTempData() # no args
{
	local tempDirs
	
	if [[ -f "$tempDirsFile" ]]; then
		tempDirs=(`cat "$tempDirsFile"`)
		
		for td in "${tempDirs[@]}"; do
			rm -rf "$td" || true # forget abou' it.
		done
		
		rm -rf "`dirname \"$tempDirsFile\"`" || true # forget abou' it.
	fi
}

function requireDir() # args: dirPath [, makeDirIfNotFound]
{
	local dirPath="$1"
	local makeDirIfNotFound="$2"
				
	if [[ ! -d "$dirPath" ]]; then
		if [[ $makeDirIfNotFound == "true" ]]; then

			mkdir -p "$dirPath" || \
				panic $? "Failed to create directory $dirPath"
				
		else
			panic 1 "Directory $dirPath not found"
		fi
	fi
}

function copyFile() # args: sourceFile, targetDirOrFile
{
	local sourceFile="$1"
	local targetDirOrFile="$2"
	
	cp -fR "$sourceFile" "$targetDirOrFile" || \
		panic $? "Failed to copy file $sourceFile to $targetDirOrFile"
}

function changeMode() # args: mode, target
{
	local mode="$1"
	local target="$2"
	
	if [[ -e "$target" ]]; then
	
		chmod $mode "$target" || \
			panic $? "Failed to change mode to $mode on $target"
	fi
}

function changeOwn() # args: ownerAndOrGroup, target
{
	local ownerAndOrGroup="$1"
	local target="$2"
	
	if [[ -e "$target" ]]; then
	
		chown "$ownerAndOrGroup" "$target" || \
			panic $? "Failed to change ownership to $ownerAndOrGroup on $target"
	fi
}

function requireFile() # args: filePath [, touchFileIfNotFound]
{
	local filePath="$1"
	local touchFileIfNotFound="$2"
	
	if [[ ! -f "$filePath" ]]; then
		if [[ $touchFileIfNotFound == "true" ]]; then

			touch "$filePath" || \
				panic $? "Failed to touch $filePath"
				
		else
			panic 1 "File $filePath not found"
		fi
	fi
}

function requireExportedVariable() # args: envVarName[, message]
{
	local envVarName="$1"
	local message="$2"
	local value
	
	if [[ ${!envVarName} == "" ]]; then
		value=`getBashProfileEnvVarValue "$envVarName"`
	
		[[ $value != "" ]] || \
			panic 1 "Environment variable $envVarName is not set or is empty"

		eval $envVarName='$value'
		export $envVarName
	fi
}

function createSymlink() # args: sourcePath, linkPath
{
	local sourcePath="$1"
	local linkPath="$2"
	
	ln -fhs "$sourcePath" "$linkPath" || \
		panic $? "Failed to create symbolic link $linkPath -> $sourcePath"
}

#拷贝文件到设备
function copyFileToDevice() # args: sourceFile, targetDir, hostAddress, hostPort
{
	local sourceFile="$1"
	local targetDir="$2"
	local hostAddress="$3"
	local hostPort="$4"
	local targetFilePath
	
	ssh -p$hostPort root@$hostAddress mkdir -p "\"$targetDir\"" || \
		panic $? "Failed to create directory $targetDir on device $hostAddress"
	
	targetFilePath="$targetDir/`basename \"$sourceFile\"`" || \
		panic $? "Failed to build target file path"
		
	ssh -p$hostPort root@$hostAddress rm -f "\"$targetFilePath\"" || \
		panic $? "Failed to remove existing file $targetFilePath on device $hostAddress"
	
	scp -P$hostPort "$sourceFile" root@$hostAddress:"\"$targetFilePath\"" || \
		panic $? "Failed to copy file $sourceFile to device $hostAddress at directory $targetDir"
}

function getBashProfileEnvVarValue() # args: envVarName
{
	$setCmd

	local envVarName="$1"
	local perlValue
	local bashProfileFile
	
	bashProfileFile=`determineBashProfileFile`
	
	perlValue=`perl -ne 'print $1 if /^(?:export)? *'"$envVarName"'=(.*)$/' "$bashProfileFile"` || \
		panic $? "Failed to perl"
	
	# return #
	echo "$perlValue"
}

function getTempDir() # no args
{
	$setCmd
	
	local tempDir
	
	tempDir=`mktemp -d -t $scriptName` || \
		panic $? "Failed to create temporary directory"

	# remember the temp dir path; in cleanup() these are rm'd #
	
	echo "$tempDir" >> "$tempDirsFile" || \
		panic $? "Failed to echo into temporary file $tempDirsFile"

	# return #
	echo "$tempDir"
}

#签名
function signCode() # args: executableToSign, identityToSignWith
{
	local executableToSign="$1"
	local identityToSignWith="$2"
	local cmdBin
	local cmdArg
	local codesignAllocatePath
	local entitlements="$CODE_SIGN_ENTITLEMENTS"

	# process arguments #
	
	requireFile "$executableToSign" false
		
	if [[ "$identityToSignWith" == "" || "$identityToSignWith" == "-" ]]; then

		# use ldid #
		cmdBin="ldid"
		
		if [[ "$entitlements" == "" ]]; then
			cmdArg=("-S")
		else
			cmdArg=("-S${PROJECT_DIR}/${entitlements}")
		fi

	else
		# use codesign #
		codesignAllocatePath=`xcodebuild -sdk iphoneos -find codesign_allocate` || \
			panic $? "Failed to get codesign_allocate path"

		export CODESIGN_ALLOCATE="$codesignAllocatePath"

		cmdBin=`xcodebuild -sdk iphoneos -find codesign` || \
			panic $? "Failed to get codesign path"

		if [[ "$entitlements" == "" ]]; then
			cmdArg=("-fs" "$identityToSignWith")
		else
			cmdArg=("-fs" "$identityToSignWith" "--entitlements" "${PROJECT_DIR}/${entitlements}")
		fi		
	fi

	echo -n "Signing $executableToSign with `basename \"$cmdBin\"`... "
	
	"$cmdBin" "${cmdArg[@]}" "$executableToSign" || \
		panic $? "Failed."

	# success #
	echo "Done."
}


#从plist读取
function readDefaultsValue() # args: plistPath, propertyName
{
	$setCmd
	
	local plistPath="$1"
	local propertyName="$2"
	local value
	
	value=`defaults read "${plistPath%.*}" "$propertyName"` || \
		panic $? "Failed to read defaults property $propertyName from $plistPath"

	# return #
	echo "$value"
}

#从plist获取版本
function getVersionFromVersionPList() # args: plistPath
{
	$setCmd
	
	local plistPath="$1"
	local version
	local major
	local minor
	local bugFix
	local stage
	local pkgRev
	
	major=`readDefaultsValue "$plistPath" "Major"`
	minor=`readDefaultsValue "$plistPath" "Minor"`
	bugFix=`readDefaultsValue "$plistPath" "BugFix"`
	stage=`readDefaultsValue "$plistPath" "Stage"`
	pkgRev=`readDefaultsValue "$plistPath" "PackageRevision"`

	version="$major.$minor"
		
	[[ "$bugFix" == "" ]] || version+=".$bugFix"
	[[ "$stage" == "" ]] || version+="$stage"
	[[ "$pkgRev" == "" ]] || version+="-$pkgRev"
		
	# return #
	echo "$version"
}

#给deb设置版本
function setControlFileVersionFieldUsingVersionPList() # args: controlFile, plistPath
{
	local controlFile="$1"
	local plistPath="$2"
	local versionReadFromPList
	
	requireFile "$controlFile" false
	requireFile "$plistPath" false
	
	# read plist to get version #
	versionReadFromPList=`getVersionFromVersionPList "$plistPath"`
	
	[[ $versionReadFromPList != "" ]] || \
		panic 1 "Failed to read version from $plistPath"

	# write version to control file	#

	echo -n "Setting control file $controlFile Version field to $versionReadFromPList using $plistPath... "

	sed -i "" "s/Version:.*/Version: $versionReadFromPList/g" "$controlFile" || \
		panic $? "Failed."

	# success #
	echo "Done."
}

#获取control文件信息
function getControlFieldValue() # args: controlFile, fieldName [, isRequired]
{
	$setCmd
	
	local controlFile="$1"
	local fieldName="$2"
	local isRequired="$3"
	local perlValue
		
	perlValue=`perl -ne 'print $1 if /^'"$fieldName"': *(.*) *$/' "$controlFile"` || \
		panic $? "Failed perl command using $controlFile"

	if [[ "$perlValue" == "" ]] && [[ "$isRequired" == "true" ]]; then
		panic 1 "Missing control field: $fieldName"
	fi
	
	# return #
	echo "$perlValue"
}

#获取pkg信息
function getPackageFileNameUsingControlFile() # args: controlFile
{
	$setCmd
	
	local controlFile="$1"
	local pkgId
	local pkgVer
	local pkgArch
		
	pkgId=`getControlFieldValue "$controlFile" Package true`
	pkgVer=`getControlFieldValue "$controlFile" Version true`
	pkgArch=`getControlFieldValue "$controlFile" Architecture true`

	# return #
	echo "${pkgId}_${pkgVer}_${pkgArch}"
}

#打包
function buildPackage() # args: packageDir, outputDir, versionPList [, useZOption]
{
	local packageDir="$1"
	local outputDir="$2"
	local versionPList="$3"
	local useZOption="$4"
	local subFilesToRemove=(".DS_Store" "0xdeadfa11")
	local packageFileName
	local packageName
	local zipFileName
	
	echo "Preparing to build package..."
	
	# verify arguments #
	requireDir "$packageDir"

	requireDir "$outputDir" true

	[[ "$versionPList" == "" ]] || \
		requireFile "$versionPList" false

	for f in "${subFilesToRemove[@]}"; do
		find "$packageDir" -type f -name "$f" -exec rm -f '{}' \; || \
			panic $? "Failed to remove file $f"
	done

	#循环去除掉文件的@属性
	xattr -crs "$packageDir" || true # forget abou' it (does not work on 10.6)

	changeMode 0644 "$packageDir/DEBIAN/control"
	changeMode 0755 "$packageDir/DEBIAN/preinst"
	changeMode 0755 "$packageDir/DEBIAN/postinst"
	changeMode 0755 "$packageDir/DEBIAN/prerm"
	changeMode 0755 "$packageDir/DEBIAN/postrm"
	
	# set control file version field #
	
	[[ "$versionPList" == "" ]] || \
		setControlFileVersionFieldUsingVersionPList "$packageDir/DEBIAN/control" "$versionPList"

	# determine package name #
	packageName=`getPackageFileNameUsingControlFile "$packageDir/DEBIAN/control"`
		
	# create package #
	createDebianPackage "$packageDir" "$packageName" "$outputDir"
	
	# create zip #
	if [[ $useZOption == "true" ]]; then

		zipFileName="$outputDir/${packageName}.zip"

		echo -n "Creating zip $zipFileName... "
		
		rm -f "$zipFileName" || \
			panic $? "Failed to remove $zipFileName"
		
		pushd "$packageDir" 1> /dev/null
		
		zip -qrX "$zipFileName" * || \
			panic $? "Failed."

		popd 1> /dev/null
		
		echo "Done."
	fi
}

#创建deb
function createDebianPackage() # args: sourceDir, packageName [, outputDir]
{
	$setCmd
	
	local sourceDir="$1"
	local packageName="$2"
	local outputDir="$3"
	
	local packageFile="${outputDir:-.}/$packageName.deb"
	
	echo -n "Building package $packageFileName... "

	local tempDir="`getTempDir`"
	
	createTarForDebianPackage "$sourceDir/DEBIAN" "$tempDir" "control" "-n"
	createTarForDebianPackage "$sourceDir" "$tempDir" "data" "--exclude" "DEBIAN/*" "--exclude" "DEBIAN"
	
	echo "2.0" > "$tempDir/debian-binary" || \
		panic $? "Failed to create debian-binary file"
	
	ar -rc "$packageFile" "$tempDir/debian-binary" "$tempDir/control.tar.gz" "$tempDir/data.tar.gz" || \
		panic $? "Failed to create Debian archive"

	echo "Done."
}

#创建tar.gz
function createTarForDebianPackage() # args: sourceDir, outputDir, tarName [, options]
{
	$setCmd
	
	local sourceDir="$1"
	local outputDir="$2"
	local tarName="$3"
	shift 3
	
	pushd "$sourceDir" 1> /dev/null

	tar -cLpz --disable-copyfile --exclude ".*" "$@" -f "$outputDir/$tarName.tar.gz" * || \
		panic $? "Failed to create $tarName archive"

	popd 1> /dev/null
}

#deb包管理 
function managePackageOnDevice() # args: manageAction, packageFileOrName, hostAddress, hostPort
{
	local manageAction="$1"
	local packageFileOrName="$2"
	local hostAddress="$3"
	local hostPort="$4"
	local doingWhat
	local direction
	local didWhat
	local cmdBin="dpkg"
	local cmdArg
	local devicePackagesDir
	
	if [[ "$manageAction" == "install" ]]; then
		doingWhat="Installing"
		direction="on"
		didWhat="installed"
		cmdArg="--install"
	elif [[ "$manageAction" == "remove" ]]; then
		doingWhat="Removing"
		direction="from"
		didWhat="removed"
		cmdArg="--remove"
	elif [[ "$manageAction" == "purge" ]]; then
		doingWhat="Purging"
		direction="from"
		didWhat="purged"
		cmdArg="--purge"
	else
		panic 1 "Invalid manage action: $manageAction"
	fi
	
	if [[ $hostAddress == "" ]]; then
	
		requireExportedVariable "MonkeyDevDevice"
		
		hostAddress="$MonkeyDevDevice"
		
		[[ $hostAddress != "" ]] || \
			hostAddress="$DefaultDevice" && echo "Host address not provided and environment variable MonkeyDevDevice is not set or is empty, use default $DefaultDevice"
	fi

	if [[ $hostPort == "" ]]; then

		hostPort="$MonkeyDevPort"

		[[ $hostPort != "" ]] || hostPort="$MonkeyDevPort"

	fi

	# if installing, copy package to device #
	if [[ $manageAction == "install" ]]; then
	
		requireFile "$packageFileOrName" false

		devicePackagesDir="/var/root/MonkeyDevPackages"

		copyFileToDevice "$packageFileOrName" "$devicePackagesDir" "$hostAddress" "$hostPort"

		packageFileOrName="$devicePackagesDir/`basename \"$packageFileOrName\"`"
	fi
	
	# install, remove or purge package #
	echo "$doingWhat package `basename \"$packageFileOrName\"` $direction device $hostAddress... "

	ssh -p$hostPort root@$hostAddress "$cmdBin" $cmdArg "$packageFileOrName" || \
		panic $? "Failed."
	
	# success #
	echo "Done."
}

#在设备执行方法
function runFuncOnDevice() # args: function, hostAddress, hostPort
{
	local func="$1"
	local hostAddress="$2"
	local hostPort="$3"
	local cmd
		
	if [[ $hostAddress == "" ]]; then
	
		requireExportedVariable "MonkeyDevDevice"
		
		hostAddress="$MonkeyDevDevice"
		
		[[ $hostAddress != "" ]] || \
			hostAddress="$DefaultDevice" && echo "Host address not provided and environment variable MonkeyDevDevice is not set or is empty, use default $DefaultDevice"
	fi

	if [[ $hostPort == "" ]]; then

		hostPort="$MonkeyDevPort"

		[[ $hostPort != "" ]] || \
			hostPort="$DefaultPort"

	fi
	
	case "$func" in
	reboot)
		cmd="reboot"
	;;
	respring)
		cmd="killall SpringBoard"
	;;
	*)
		panic $? "Invalid function: $func"
	;;
	esac
	  
	ssh -p$hostPort root@$hostAddress $cmd || \
		panic $? "Failed to perform function $func on device $hostAddress"
}

#sudo
function requireSudo() # args: ...
{
	if [[ $EUID != 0 ]]; then
	
		removeTempData
		
		exec sudo "$0" "$@" || \
			panic $? "Failed to re-execute as root"
	fi
}

#从文件匹配内容
function doesFileContain() # args: filePath, pattern
{
	$setCmd
	
	local filePath="$1"
	local pattern="$2"
	local perlValue
	local funcReturn
	
	perlValue=`perl -ne 'if (/'"$pattern"'/) { print "true"; exit; }' "$filePath"` || \
		panic $? "Failed to perl"

	if [[ $perlValue == "true" ]]; then
		funcReturn="true"
	else
		funcReturn="false"
	fi
	
	# return #
	echo $funcReturn
}

# 	--xcbp-logos
function xcodeBuildPhase_Logos() # no args
{
	[[ "$ACTION" == "build" ]] || \
		panic 1 "For Xcode Build Phase use only"
	
	echo "Preparing to run Xcode Build Phase for Logos Processor..."

	local pbxProjectFilePath="$PROJECT_FILE_PATH/project.pbxproj"
	local logosProcessor
	local projectFileModified=false
	local projectContainsXmFiles
	local projectContainsXFiles
	local lastKnownXmFileTypeNotObjCpp
	local lastKnownXFileTypeNotObjC
	local xmFileLangSpecNotObjCpp
	local xFileLangSpecNotObjC
	local projectXmFiles
	local projectXFiles
	local logosStdErr
	local logosErr=0
	
	[[ -f "$pbxProjectFilePath" ]] || \
		panic 1 "Xcode project file not found: $pbxProjectFilePath"
	
	#没有安装Theos？
	logosProcessor=`which logos.pl` || \
		panic $? "Failed to locate Logos Processor. Is Theos installed? If not, see https://github.com/theos/theos/wiki/Installation."
	
	#修改文件类型
	projectContainsXmFiles=`doesFileContain "$pbxProjectFilePath" '\/\* .+\.xm \*\/ *= *\{.*?isa *= *PBXFileReference\b'`
	projectContainsXFiles=`doesFileContain "$pbxProjectFilePath" '\/\* .+\.x \*\/ *= *\{.*?isa *= *PBXFileReference\b'`
	
	if [[ $projectContainsXmFiles == "true" ]]; then
	
		lastKnownXmFileTypeNotObjCpp=`doesFileContain "$pbxProjectFilePath" '\/\* .+\.xm \*\/ *= *\{.*?isa *= *PBXFileReference\b[^\}]*?\blastKnownFileType *= *text\b'`
		
		if [[ $lastKnownXmFileTypeNotObjCpp == "true" ]]; then
			echo "Modifying Xcode project file: setting *.xm file-types to Objective-C++..."
			
			perl -i -pe 's/^(.*\/\* .+\.xm \*\/ *= *{.*?isa *= *PBXFileReference\b[^}]*?\blastKnownFileType *= *)[^;]+(.*)$/\1sourcecode.cpp.objcpp\2/g' "$pbxProjectFilePath" || \
				panic $? "Failed to modify Xcode project file"
	
			projectFileModified=true
		fi
	
		xmFileLangSpecNotObjCpp=`perl -ne 'if ($_ =~ /\/\* .+\.xm \*\/ *= *\{.*?isa *= *PBXFileReference\b/ && $_ !~ /\bxcLanguageSpecificationIdentifier *= *xcode\.lang\.objcpp\b/) { print "true"; exit; }' "$pbxProjectFilePath"` || \
			panic $? "Failed to execute perl on $pbxProjectFilePath"
	
		if [[ $xmFileLangSpecNotObjCpp == "true" ]]; then
			echo "Modifying Xcode project file: setting *.xm language to Objective-C++..."
			
			perl -i -pe 'if ($_ =~ /\/\* .+\.xm \*\/ *= *\{.*?isa *= *PBXFileReference\b/ && $_ !~ /\bxcLanguageSpecificationIdentifier *= *xcode\.lang\.objcpp\b/) { s/^(.*\/\* .+\.xm \*\/ *= *{.*?isa *= *PBXFileReference\b[^}]*)(.*)$/\1xcLanguageSpecificationIdentifier = xcode.lang.objcpp; \2/g; }' "$pbxProjectFilePath" || \
				panic $? "Failed to modify Xcode project file"
		
			projectFileModified=true
		fi

		#explicitFileType
	fi
	
	if [[ $projectContainsXFiles == "true" ]]; then
	
		lastKnownXFileTypeNotObjCpp=`doesFileContain "$pbxProjectFilePath" '\/\* .+\.x \*\/ *= *\{.*?isa *= *PBXFileReference\b[^\}]*?\blastKnownFileType *= *text\b'`
	
		if [[ $lastKnownXFileTypeNotObjC == "true" ]]; then
			echo "Modifying Xcode project file: setting *.x file-types to Objective-C..."
			
			perl -i -pe 's/^(.*\/\* .+\.x \*\/ *= *{.*?isa *= *PBXFileReference\b[^}]*?\blastKnownFileType *= *)[^;]+(.*)$/\1sourcecode.c.objc\2/g' "$pbxProjectFilePath" || \
				panic $? "Failed to modify Xcode project file"
	
			projectFileModified=true
		fi
	
		xFileLangSpecNotObjC=`perl -ne 'if ($_ =~ /\/\* .+\.x \*\/ *= *\{.*?isa *= *PBXFileReference\b/ && $_ !~ /\bxcLanguageSpecificationIdentifier *= *xcode\.lang\.objc\b/) { print "true"; exit; }' "$pbxProjectFilePath"` || \
			panic $? "Failed to execute perl on $pbxProjectFilePath"
	
		if [[ $xFileLangSpecNotObjC == "true" ]]; then
			echo "Modifying Xcode project file: setting *.x language to Objective-C..."
			
			perl -i -pe 'if ($_ =~ /\/\* .+\.x \*\/ *= *\{.*?isa *= *PBXFileReference\b/ && $_ !~ /\bxcLanguageSpecificationIdentifier *= *xcode\.lang\.objc\b/) { s/^(.*\/\* .+\.x \*\/ *= *{.*?isa *= *PBXFileReference\b[^}]*)(.*)$/\1xcLanguageSpecificationIdentifier = xcode.lang.objc; \2/g; }' "$pbxProjectFilePath" || \
				panic $? "Failed to modify Xcode project file"
		
			projectFileModified=true
		fi
	fi
	
	if [[ $projectFileModified == "true" ]]; then
		echo "DON'T WORRY, EVERYTHING IS OK!"
		echo "The Xcode project file was modified to provide better *.xm & *.x file support."
		echo "To dismiss this build error, just perform the build again."
		panic 1
	fi
	
	# for each *.xm project file, use Logos Processor to generate *.mm file
	projectXmFiles=($(perl -ne 'if ($_ =~ /\/\* (.+\.xm) \*\/ *= *{.*?isa *= *PBXFileReference\b/) { print "$1\n"; }' "$pbxProjectFilePath"))
	projectXFiles=($(perl -ne 'if ($_ =~ /\/\* (.+\.x) \*\/ *= *{.*?isa *= *PBXFileReference\b/) { print "$1\n"; }' "$pbxProjectFilePath"))
	
	for f in "${projectXmFiles[@]}"; do
		echo "Logos Processor: $f -> ${f%.*}.mm..."

		logosStdErr=$(("$logosProcessor" "$PROJECT_DIR/$TARGET_NAME/$f" > "$PROJECT_DIR/$TARGET_NAME/${f%.*}.mm") 2>&1) || \
			logosErr=$?
		
		if [[ $logosErr != 0 ]]; then
			echo "Failed Logos Processor" >&2
			echo "Logos Processor outputted:" >&2
			echo "$logosStdErr" >&2
			exit $logosErr
		fi
		
	done
	
	for f in "${projectXFiles[@]}"; do
		echo "Logos Processor: $f -> ${f%.*}.m..."

		logosStdErr=$(("$logosProcessor" "$PROJECT_DIR/$TARGET_NAME/$f" > "$PROJECT_DIR/$TARGET_NAME/${f%.*}.m") 2>&1) || \
			panic $? "Failed Logos Processor"
	
		[[ $logosStdErr == "" ]] || \
			panic 1 "Logos Processor outputted: $logosStdErr"
	done

	echo "Note: If any *.xm or *.x file generated above by the Logos Processor (${projectXmFiles[@]}) is not being compiled below, then you must add it to the Xcode project to be compiled."

	echo "Xcode Build Phase for Logos Processor complete."
}

#  --xcbp
function xcodeBuildPhase() # no args
{
	[[ "$ACTION" == "build" ]] || \
		panic 1 "For Xcode Build Phase use only"
	
	echo "Preparing to run Xcode Build Phase..."
	
	#编译可执行文件路径
	local builtExecutable="$TARGET_BUILD_DIR/$EXECUTABLE_PATH"
	#deb打包文件夹目录
	local packageDirectory="$PROJECT_DIR/$TARGET_NAME/Package"
	#安装的目录
	local packageInstallPath="$packageDirectory$INSTALL_PATH"
	#deb版本文件
	local packageVersionPListPath="$PROJECT_DIR/$TARGET_NAME/PackageVersion.plist"
	#存放所有deb目录
	local allPackagesDir="$PROJECT_DIR/Packages"
	#编译产品输出目录
	local builtProductsDir="$BUILT_PRODUCTS_DIR"
	#最新的编译版本
	local latestBuildSymlink="$PROJECT_DIR/LatestBuild"
	local stripBin
	local stripOption
	local versionPListPath
	local packageFileName
	
	#目标文件路径
	local packageInstallSource
	if [[ $SHALLOW_BUNDLE != "YES" ]]; then
		packageInstallSource="$TARGET_BUILD_DIR/$EXECUTABLE_PATH"
	else
		packageInstallSource="$TARGET_BUILD_DIR/$EXECUTABLE_FOLDER_PATH"
	fi

	#如果编译设置里面MonkeyDevDevice为空的话，就从用户的profile里面去拿，否则使用默认值
	[[ $MonkeyDevDevice != "" ]] || \
		MonkeyDevDevice=`getBashProfileEnvVarValue "MonkeyDevDevice"`
	[[ $MonkeyDevDevice != "" ]] || \
		MonkeyDevDevice="$DefaultDevice" && echo "use default $DefaultDevice"

	#如果编译设置里面MonkeyDevPort为空的话，就从用户的profile里面去拿，否则使用默认值
	[[ $MonkeyDevPort != "" ]] || \
		MonkeyDevPort=`getBashProfileEnvVarValue "MonkeyDevPort"`

	[[ $MonkeyDevPort != "" ]] || \
		MonkeyDevPort="$DefaultPort"

	#验证必要文件的存在
	requireFile "$builtExecutable" false
	requireDir "$packageDirectory"
	
	#创建最后一个编译的符号链接
	createSymlink "$builtProductsDir" "$latestBuildSymlink"

	#如果是Profile，strip可执行文件
	if [[ "$CONFIGURATION" == "Release" && "$VALIDATE_PRODUCT" == "YES" ]]; then
		if [[ "$STRIP_INSTALLED_PRODUCT" == "YES" ]]; then

			stripBin=`xcodebuild -sdk iphoneos -find strip` || \
				panic $? "Failed to get strip path"

			echo "$stripBin"

			[[ "$STRIP_STYLE" != "debugging" ]] || stripOption="-S"

			echo "Stripping $builtExecutable..."

			"$stripBin" $stripOption "$builtExecutable" || \
				panic $? "Failed to strip $builtExecutable"
		fi
	fi

	#静态库跳过签名
	if [[ "$MACH_O_TYPE" == "staticlib" && "$CODE_SIGN_IDENTITY" == "" ]]; then
		echo "Skipping signing (since ldid would be used and it fails on static libraries)"
	elif [[ "$PLATFORM_NAME" != "iphoneos" ]]; then
		echo "Skipping signing (since platform is not iphoneos)"
	else
		signCode "$builtExecutable" "$CODE_SIGN_IDENTITY"
	fi

	changeMode "$INSTALL_MODE_FLAG" "$builtExecutable"

	#是否需要拷贝到设备
	if [[ "$MonkeyDevCopyOnBuild" == "YES" ]]; then
	
		#拷贝到设备的/var/root/MonkeyDevBuilds/
		if [[ "$MonkeyDevDevice" != "" ]]; then
			copyFileToDevice "$builtExecutable" "/var/root/MonkeyDevBuilds/$PROJECT_NAME" "$MonkeyDevDevice" "$MonkeyDevPort"
		else
			# build setting MonkeyDevDevice is empty #
			panic 1 "Unable to copy executable to device since build setting MonkeyDevDevice is not set or is empty and it is not exported in your Bash personal initialization file"
		fi
	
	fi

	#如果是profie或者用户设置了每次build都install或package，生成deb
	if [[ "$CONFIGURATION" == "Release" && "$VALIDATE_PRODUCT" == "YES" ]] || [[ "$MonkeyDevInstallOnAnyBuild" == "YES" ]] || [[ "$MonkeyDevBuildPackageOnAnyBuild" == "YES" ]]; then
		#准备打包
		echo "Copying $packageInstallSource to package directory at $packageInstallPath..."
		
		requireDir "$packageInstallPath" true
		
		#拷贝目标文件到/Package/Library/MobileSubstrate/DynamicLibraries
		copyFile "$packageInstallSource" "$packageInstallPath"

		#生成deb
		[[ "$MonkeyDevUsePackageVersionPList" != "YES" ]] || \
			versionPListPath="$packageVersionPListPath"			
		
		echo "$versionPListPath"

		buildPackage "$packageDirectory" "$allPackagesDir" "$versionPListPath" true
		
		#profile或者用户设置了build安装
		if [[ "$CONFIGURATION" == "Release" && "$VALIDATE_PRODUCT" == "YES" ]] || [[ "$MonkeyDevInstallOnAnyBuild" == "YES" ]]; then
		
			if [[ "$DEPLOYMENT_POSTPROCESSING" == "NO" || "$MonkeyDevInstallOnAnyBuild" == "YES" ]]; then
			
				# if build setting MonkeyDevInstallOnProfiling is enabled, installation of package is enabled...
				if [[ "$MonkeyDevInstallOnProfiling" == "YES"  || "$MonkeyDevInstallOnAnyBuild" == "YES" ]]; then
				
					# if MonkeyDevDevice has a value, install package on device...
					if [[ "$MonkeyDevDevice" != "" ]]; then
	
						# get package file name #
						packageFileName="`getPackageFileNameUsingControlFile \"$packageDirectory/DEBIAN/control\"`.deb"
							
						# install package on device #					
						managePackageOnDevice "install" "$allPackagesDir/$packageFileName" "$MonkeyDevDevice" "$MonkeyDevPort"
						
						# respring? #
						if [[ "$MonkeyDevRespringOnInstall" == "YES" ]]; then
							echo "Respringing device..."
							runFuncOnDevice "respring" "$MonkeyDevDevice" "$MonkeyDevPort" 
						fi
					else
						# build setting MonkeyDevDevice is empty #
						panic 1 "Unable to install package on device since build setting MonkeyDevDevice is not set or is empty and it is not exported in your Bash personal initialization file"
					fi
				else
					# build setting MonkeyDevInstallOnProfiling is disabled #
					echo "Installation of package on device is disabled. To enable, set build setting MonkeyDevInstallOnProfiling to YES."
				fi
			fi
		fi
	fi

	echo "Xcode Build Phase complete."
}

#用法
function showUsageAndExit() # args: showEverything
{
	local showEverything="$1"
	local n
	
	echo "$scriptName (v$scriptVer) -- MonkeyDev Command-line Tool"
	echo "Usages:"
	
	for n in "${ActionNames[@]}"; do
		eval echo "\"    $scriptName \${Action_$n[$ActionProperty_ShortArg]} \${Action_$n[$ActionProperty_ShortUsage]}\""
	done
	
	if [[ $showEverything == "true" ]]; then
		echo
		echo "Actions:"
		
		for n in "${ActionNames[@]}"; do
			eval echo "\"    \${Action_$n[$ActionProperty_ShortArg]} \${Action_$n[$ActionProperty_ShortUsage]}\""
			eval echo "\"\${Action_$n[$ActionProperty_LongUsage]}\""
			echo
		done
	fi

	panic 1
}

function showSingleUsageAndExit()
{
	panic 1 "Usage: $scriptName ${activeActionArg[$ActionProperty_ShortArg]} ${activeActionArg[$ActionProperty_ShortUsage]}

${activeActionArg[$ActionProperty_LongUsage]}
"
		
}

#脚本开始
[[ $1 != "" ]] || showUsageAndExit false
[[ $1 != "--help" ]] || showUsageAndExit true

#寻找有没有对应的参数
for n in "${ActionNames[@]}"; do
	foundArg=false
	eval [[ "\$1" != "\${Action_$n[$ActionProperty_ShortArg]}" ]] || \
		foundArg=true

	if [[ $foundArg == true ]]; then
		eval activeActionArg=("\"\${Action_$n[@]}\"")
		break;
	fi
done

[[ $foundArg == true ]] || \
	panic 1 "Invalid argument: $1"

[[ "$#" != 1 || ${activeActionArg[$ActionProperty_MinArgs]} == 0 ]] || \
	showSingleUsageAndExit

shift 1

while getopts ":${activeActionArg[$ActionProperty_Options]}" opt; do
	case "$opt" in
	\?)
		panic 1 "Invalid option: -$OPTARG"
	;;
	*)
		[[ $opt != ":" ]] || \
			panic 1 "Option missing value: -$OPTARG"

		eval Opt_$opt="\"${OPTARG-true}\""  #可选参数赋值
	;;
	esac
done

shift $(($OPTIND - 1)) # shift out options

(( "$#" >= ${activeActionArg[$ActionProperty_MinArgs]} && "$#" <= ${activeActionArg[$ActionProperty_MaxArgs]} )) || \
	showSingleUsageAndExit

#执行Action
[[ ${activeActionArg[$ActionProperty_RequireSudo]} == false ]] || \
	requireSudo "${originalArguments[@]}"

case "${activeActionArg[$ActionProperty_ShortArg]}" in
	${Action_XcodeBuildPhase[$ActionProperty_ShortArg]})
		"${activeActionArg[$ActionProperty_Function]}"
	;;
	${Action_XcodeBuildPhaseLogos[$ActionProperty_ShortArg]})
		"${activeActionArg[$ActionProperty_Function]}"
	;;
esac

exit 0
